<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title></title>
</head>
<style>
  div.container {
    display: flex;
    justify-content: center;
    flex-direction: column;
  }
  canvas#my-canvas {
    width: 100%;
  }
  #div-canvas {
    width: 90vw;
    height: 500px;
    margin: auto;
    overflow: scroll;
    border: 1px solid black;
  }
  button#step-btn {
    width: 300px;
    margin: 20px;
    font-size: 24px;
    align-self: center;
  }
</style>
<body>
  
  <div class="container">
    <button id="step-btn">Step</button>
    <div id="div-canvas">
      <canvas id="my-canvas"></canvas>
    </div>
  </div>
  <script>
    const myCanvas = document.getElementById('my-canvas'); 
    const context = myCanvas.getContext('2d',{willReadFrequently: true});
  </script>
  <script src="./js.js"></script>
  <script>
    const img = new Image();        
    img.src = './sample-page.png';        
    img.onload = () => { 
      // Put the image on to a virtual canvas matching the original size.
      // This is to work with the canvas data at maximum resolution while still
      // being able to zoom out the canvas for larger image widths.

      const canvas2 = document.createElement('canvas');
      const context2 = canvas2.getContext('2d');
      canvas2.width = img.width;
      canvas2.height = img.height;
      context2.drawImage(img, 0, 0, img.width, img.height );
      const myData = context2.getImageData(0, 0, img.width, img.height);

      const div_canvas = document.getElementById("div-canvas");

      const canvas_scale = img.width / div_canvas.clientWidth;

      const canvas_height = img.height / canvas_scale;
      const canvas_width = img.width / canvas_scale;
      myCanvas.height = canvas_height; //img.height;
      myCanvas.width = canvas_width; //img.width;
      context.drawImage(img, 0, 0, canvas_width, canvas_height );
      // Read the pixel data of the canvas
      //const imageData1 = context.getImageData(0, 0, img.width, img.height);
      const data = myData.data;
      let raster = data_to_raster(data, img.width, img.height);
      let boxes = find_boxes(raster); 
      let row_sorted = get_row_sorted(boxes);
      console.log(data.length);
      console.log(`Image Width ${img.width} and ${img.height}`);
      let btn = document.getElementById("step-btn");
      //rowBoxes = new RowBoxes(boxes, {});
      let imageData = null;
      let x,y,width,height;
      let majorIdx = 0;
      let minorIdx = 0;
      btn.addEventListener("click", function() {
        //let settings = {willReadFrequently: true};
        let [x1, y1, x2, y2] = row_sorted[majorIdx][minorIdx];

        if (imageData !== null) {
          [x,y] = [imageData.x, imageData.y];
          //context.putImageData(imageData.image, x-2,y-2);
        }
        //let [smallBox, largeBox] = rowBoxes.click();
        //console.log(smallBox);
        // [x1, y1, x2, y2] = smallBox;
        context.strokeStyle = 'red';
        context.lineWidth=2;
        context.strokeRect((x1-3)/canvas_scale, (y1-3)/canvas_scale, (x2-x1+3)/canvas_scale, (y2-y1+3)/canvas_scale);
        //[x1, y1, x2, y2] = [largeBox.xmin, largeBox.ymin, largeBox.xmax, largeBox.ymax];
        x = x1 - 3;
        y = y1 - 3;
        width = x2 - x1 + 6;
        height = y2 - y1 + 6;
        imageData = {x:x, y:y, width: width, height: height };
        imageData['image'] = context.getImageData(x-2,y-2,width+4, height+4);
        context.strokeStyle = 'blue';
        context.lineWidth=3;
        minorIdx++;
        if (minorIdx >= row_sorted[majorIdx].length) {
          majorIdx++;
          minorIdx = 0;
          if (majorIdx >= row_sorted.length) {
            return null;
          }
        }
        //context.strokeRect(x, y, width, height);
      });
    };
    

  </script>
</body>
</html>
